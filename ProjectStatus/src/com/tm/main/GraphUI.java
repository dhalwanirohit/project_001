/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.tm.main;

import com.tm.hiber.model.TaskMaster;
import com.tm.hiber.service.TaskManagerService;
import com.tm.hiber.service.TaskManagerServiceImpl;
import com.tm.hiber.service.util.UtilService;
import com.tm.model.CellGraphDataRenderer;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.ListSelectionModel;
import javax.swing.SwingConstants;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;
import org.hibernate.criterion.Criterion;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Restrictions;

/**
 *
 * @author user
 */
public class GraphUI extends javax.swing.JFrame {

    /**
     * Creates new form GraphUI
     */
    List<Integer> mListDayRange = new ArrayList<Integer>();

    public GraphUI() {
        initComponents();
        setExtendedState(MAXIMIZED_BOTH);
        setTitle("Graph");
        JTableHeader jh = jTable1.getTableHeader();
        TableCellRenderer tc = jh.getDefaultRenderer();
        DefaultTableCellRenderer dtc = (DefaultTableCellRenderer) tc;
        dtc.setHorizontalAlignment(SwingConstants.CENTER);
        jh.setFont(new Font("Calibri", Font.BOLD, 12));

        jTable1.setFont(new Font("Calibri", Font.PLAIN, 12));
        jTable1.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        
        setIconImage(UtilService.self().getIcon("/com/tm/system/icons16/Line_Graph_16x16.png").getImage());
        
        jDateChooser1.setDate(UtilService.self().getDateByDay(Calendar.MONDAY));
        jDateChooser2.setDate(UtilService.self().getDateByDay(Calendar.FRIDAY));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jDateChooser1 = new com.toedter.calendar.JDateChooser();
        jDateChooser2 = new com.toedter.calendar.JDateChooser();
        jButton1 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jButton1.setText("Draw Chart");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        jScrollPane1.setViewportView(jTable1);

        jLabel1.setFont(new java.awt.Font("Calibri", 0, 12)); // NOI18N
        jLabel1.setText("From:");

        jLabel2.setFont(new java.awt.Font("Calibri", 0, 12)); // NOI18N
        jLabel2.setText("To:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 654, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jDateChooser1, javax.swing.GroupLayout.PREFERRED_SIZE, 152, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jDateChooser2, javax.swing.GroupLayout.PREFERRED_SIZE, 152, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {jDateChooser1, jDateChooser2});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(jLabel1)
                    .addComponent(jDateChooser1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2)
                    .addComponent(jDateChooser2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 303, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        Calendar fromDate = jDateChooser1.getCalendar();
        Calendar toDate = jDateChooser2.getCalendar();
        
        if (fromDate != null && toDate != null && fromDate.before(toDate)) {
            mListDayRange.clear();
            while (fromDate.before(toDate)) {
                mListDayRange.add(fromDate.get(Calendar.DATE));
                fromDate.add(Calendar.DATE, 1);
            }
            renderTable();
        }
        
    }//GEN-LAST:event_jButton1ActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private com.toedter.calendar.JDateChooser jDateChooser1;
    private com.toedter.calendar.JDateChooser jDateChooser2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    // End of variables declaration//GEN-END:variables

    private void renderTable() {
        DefaultTableModel dtm = new DefaultTableModel();
        dtm.addColumn("User");
        dtm.addColumn("Project");
        dtm.addColumn("Task");        
        TaskManagerService lTaskManagerService = new TaskManagerServiceImpl();

        Object[] columns = getTableHeader();

        for (int i = 0; i < columns.length; i++) {
            dtm.addColumn(new SimpleDateFormat("dd.MMM.yy").format(columns[i]));
        }

        List<Criterion> criteria = new ArrayList<Criterion>();

        Criterion c2 = Restrictions.ne("status", "-1");
        criteria.add(c2);
        
        Criterion c3 = Restrictions.isNotNull("assignee");
        criteria.add(c3);
        
        Criterion c4 = Restrictions.ne("assignee","-1");
        criteria.add(c4);
        
        List<Order> listOrders = new ArrayList<Order>();
        Order objOrderByEmployee = Order.asc("assignee");
        listOrders.add(objOrderByEmployee);
        
        List<TaskMaster> assignments = lTaskManagerService.getAllTask(criteria,listOrders);

        for (int j = 0; j < assignments.size(); j++) {
            Object[] rowData = getRow(assignments.get(j));
            Object[] row = getFormatedRow(columns, rowData);

            if (!isBlankRow(row)) {
                row[0] = SystemUI.mUserMasterData.get(assignments.get(j).getAssignee());                
                row[1] = SystemUI.mProjectMasterData.get(assignments.get(j).getProjectName());
                row[2] = assignments.get(j).getTaskReference();
                dtm.addRow(getBlankRow(columns));
                dtm.addRow(row);
                
            }

        }
        dtm.addRow(getBlankRow(columns));

        jTable1.setEnabled(false);
        jTable1.setShowGrid(false);
        jTable1.setIntercellSpacing(new Dimension(0, 0));
        jTable1.setModel(dtm);

        Map<String, Color> mMapColors = new HashMap<String, Color>();
//        mMapColors.put("ROHIT_2", Color.blue);
//        mMapColors.put("ROHIT_1", Color.red);
//        mMapColors.put("ROHIT_3", Color.yellow);

        mMapColors = getGraphColor(SystemUI.mUserMasterData);

        jTable1.getColumnModel().getColumn(0).setCellRenderer(new CellGraphDataRenderer(mMapColors));
        jTable1.getColumnModel().getColumn(1).setCellRenderer(new CellGraphDataRenderer(mMapColors));
        jTable1.getColumnModel().getColumn(2).setCellRenderer(new CellGraphDataRenderer(mMapColors));
        for (int i = 0; i < columns.length; i++) {
            jTable1.getColumnModel().getColumn(i + 3).setCellRenderer(new CellGraphDataRenderer(mMapColors));
        }

        UtilService.self().setColumnSize(0, 100, jTable1);
        UtilService.self().setColumnSize(1, 100, jTable1);
        UtilService.self().setColumnSize(2, 100, jTable1);
        jTable1.validate();

        DefaultTableCellRenderer cellRenderer = (DefaultTableCellRenderer) jTable1.getCellRenderer(0, 0);
        cellRenderer.setHorizontalAlignment(SwingConstants.CENTER);
        cellRenderer.setVerticalAlignment(SwingConstants.TOP);

    }

    private List<Date> getDates(TaskMaster objTaskMaster) {
        List<Date> response = new ArrayList<Date>();
        if (objTaskMaster != null && objTaskMaster.getCreateDate() != null && objTaskMaster.getEta() != null) {
            Calendar clStartCal = Calendar.getInstance();
            clStartCal.setTime(objTaskMaster.getCreateDate());
            Calendar clEndcal = Calendar.getInstance();
            clEndcal.setTime(objTaskMaster.getEta());
            while (clStartCal.getTime().compareTo(clEndcal.getTime()) <= 0) {
                response.add(clStartCal.getTime());
                clStartCal.add(Calendar.DATE, 1);
            }
        }
        return response;
    }

    private List<Date> getDates(Calendar clStartCal, Calendar clEndCal) {
        List<Date> response = new ArrayList<Date>();
        if (clStartCal != null && clEndCal != null) {
            while (clStartCal.getTime().compareTo(clEndCal.getTime()) <= 0) {
                response.add(clStartCal.getTime());
                clStartCal.add(Calendar.DATE, 1);
            }
        }
        return response;
    }

    private Object[] getTableHeader() {
        Calendar startCal = jDateChooser1.getCalendar();
        Calendar endCal = jDateChooser2.getCalendar();
        return getDates(startCal, endCal).toArray();
    }

    private Object[] getRow(TaskMaster objTaskMaster) {
        return getDates(objTaskMaster).toArray();
    }

    private Object[] getFormatedRow(Object[] requiredData, Object[] actualData) {
        List<String> formatedData = new ArrayList<String>();
        formatedData.add("USER");
        formatedData.add("PROJECT");
        formatedData.add("TASK");        
        for (int i = 0; i < requiredData.length; i++) {
            int result = Arrays.binarySearch(actualData, requiredData[i]);
            if (result < 0) {
                formatedData.add("FREE");
            } else {
                formatedData.add("BUSY");
            }
        }
        return formatedData.toArray();
    }

    private boolean isBlankRow(Object[] formatedRow) {
        return !Arrays.asList(formatedRow).contains("BUSY");
    }

    private Map<String, Color> getGraphColor(Map<String, String> users) {
        Map<String, Color> response = new HashMap<String, Color>();
        List<Color> randomColor = UtilService.self().getRandomColor(users.size());
        Set<String> setUserId = users.keySet();
        Iterator<String> itrUserId = setUserId.iterator();
        int counter = 0;
        while (itrUserId.hasNext()) {
            String userId = itrUserId.next();
            response.put(users.get(userId), randomColor.get(counter));
            counter++;
        }
        return response;
    }

    private Object[] getBlankRow(Object[] columns) {
        Object[] response = new Object[columns.length + 2];
        for (int i = 0; i < response.length; i++) {
            response[i] = "BLANK";
        }
        return response;
    }

}
